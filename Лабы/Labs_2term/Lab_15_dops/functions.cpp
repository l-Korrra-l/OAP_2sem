

#include "Hash.h"

#include <iostream>

int HashFunction(int key, int size, int p)
{

	return ((int)(key % size + (key % size + 1) * p) % size);

}

int Next_hash(int key, int size, int p) 

{

	return ((key % size + (key % size + 1) * p) % size); 

}

Object Create(int size, int(*getkey)(void*)) 
{

	return *(new Object(size, getkey));

}

Object::Object(int size, int(*getkey)(void*)) 

{

	N = 0; 
	this->Size = size; // задаём указанный максимальный размер

	this->GetKey = getkey; // запоминаем функцию для получения ключа из элемента

	this->Data = new void* [size]; // выделение памяти под массив элементов

	for (int i = 0; i < size; ++i) // устанавливаем все элементыв ноль для обозначения их пустоты

		Data[i] = NULL;

}

bool Object::Insert(void* d) // функция вставки элементов в хэш-таблицу

{

	bool b = false;

	if (N != Size) // если текущее количество не равно размеру хэш-таблиц (ещё есть свободные места)

	// i - счётчик колизий, t - ключ вставляемого элемента, получаемый функцией GetKey,

	// j - позиция для вставки, расчитываем по хэш-функции HashFunction

		for (int i = 0, t = GetKey(d), j = HashFunction(t, Size, 0); i != Size * Size && !b; j = Next_hash(j, Size, ++i))

			// i != Size&&!b - пока счётчик колизий не достигнет размера хэш-таблицы и пока элемент небудет вставлен // j = Next_hash(j, Size, ++i) - при колизиях увеличиваем счётчик и пересччитываем позицию по хэш-функции

			if (Data[j] == NULL || Data[j] == DEL)

				// если расчитанная позиция всегдабыла свободна или элемент, который на ней был, был удалён

			{

				Data[j] = d;

				// записываем в рассчитанную позицию вставляемый Э-т, то есть структуру, содержащую ключ

				N++; // увеличиваем счётчик Э-ов

				b = true; // признак выхода из цикла, то есть Э-т уже вставлен

			}

	return b;

}

int Object::SearchInd(int key) // функция поиска позиции Э-а (структуры) по ключу в хэш-таблице

{

	int t = -1; // номер найденного Э-а, если ничего не нашли, то возвращает функция -1

	bool b = false; // признак найден Э-т или нет

	if (N != 0) // если в таблице уже есть Э-ты, то есть текущее к-во Э-в!=0

		for (int i = 0, j = HashFunction(key, Size, 0); Data[j] != NULL && i != Size * Size && !b; j = HashFunction(key, Size, ++i))

			if (Data[j] != DEL) // если на текущей позиции не удалён Э-т

				if (GetKey(Data[j]) == key)

					// сравниваем ключ эл-та на тек. позиции с искомым ключом

				{

					// если совпадают ключи, то запоминаем позицию заданного эл-та

					t = j; // номер найденного эл-та

					b = true; // -1 , если эл-т не найден

				}

	return t; // возвращ. позицию найденного эл-та

}

void* Object::Search(int key) // функция поиска Э-та по ключу

{

	int t = SearchInd(key);

	// вызываем функцию поиска позиции по ключу и записываем в перемнную t эту позицию

	return (t >= 0) ? (Data[t]) : (NULL);

	// если эл-т найден (t >= 0), возвращаем хранящиеся в нем данные, иначе возвращ. 0

}

void* Object::Delete(int key) // функция удаления по ключу, которая возвращает У-ль на данные, У-ль на которые будет удалён из хэш-таблицы

{

	int i = SearchInd(key);

	// вызываем функцию поиска позиции по ключу и записываем в перемнную t эту позицию

	void* t = Data[i]; // У-ль на данные в стороке хэш-таблицы с найденной позицией

	if (t != NULL) // если данные есть

	{

		Data[i] = DEL; // в качестве нового значения указателя записываем -1, то есть показываем, что Э-т в этой позиции был удален

		N--; // уменьшам кол-во текущих Э-в

	}

	return t;

}

bool Object::Delete(void* d) // функция удаления Э-а по данным

{

	// 1. получаем ключ по переданным данным: (GetKey(d)

	// 2. вызываемфункцию удаления по найденному ключу

	// 3. возвращаем сравнение результата фунции удаления с NULLом

	return (Delete(GetKey(d)) != NULL);

}

void Object::Scan(void(*f)(void*))

// функция вывода хэш-таблицы, которая принимает функцию для вывода одного Э-а

// а та в свою очередь принимает в качестве аргумента У-ль на произвольные данные

{

	for (int i = 0; i < this->Size; i++) // цикл для вывода хэш-таблицы построчно

	{

		std::cout << " Элемент " << i << ": ";

		if ((this->Data)[i] == NULL) // если данных нет и не было

			std::cout << " пусто" << std::endl;

		else if ((this->Data)[i] == DEL)

			// если данных нет, но они были до этого, а потом их удалили

			std::cout << " удален" << std::endl;

		else f((this->Data)[i]); // выводим значение Э-та (структуру) при помощи заданной функции

	}

}

double Object::koefzap() // функция для расчёта коэффициента заполненности хэш-таблицы

{

	return (double)N / Size;// текущее к-во Э-в делим на максимальное к-во Э-в в хэш-таблице (её размер), возвращаем дробное число

}